const dataStore = new WeakMap();
!('skidata' in Node.prototype) &&
    Object.defineProperty(Node.prototype, 'skidata', {
        get() {
            let data = dataStore.get(this);
            if (!data)
                dataStore.set(this, data = {});
            return this.parentNode ?
                Object.setPrototypeOf(data, this.parentNode.skidata) :
                this instanceof Attr && this.ownerElement ?
                    Object.setPrototypeOf(data, this.ownerElement.skidata) :
                    data;
        }
    });

const DONE = Promise.resolve({ value: undefined, done: true });
class ExtendedAsyncGenerator {
    async then(onfulfilled, onrejected) {
        try {
            do {
                var { value, done } = await this.next();
            } while (!done);
            return onfulfilled(value);
        }
        catch (e) {
            onrejected(e);
        }
    }
}
Object.assign(ExtendedAsyncGenerator.prototype, {
    next(arg) { return this.__asyncIterator__.next(arg); },
    return(arg) { return this.__asyncIterator__.return(arg); },
    throw(arg) { return this.__asyncIterator__.throw(arg); }
});
Object.defineProperty(ExtendedAsyncGenerator.prototype, '__asyncIterator__', {
    get() {
        Object.defineProperty(this, '__asyncIterator__', {
            value: this[Symbol.asyncIterator](),
            enumerable: false
        });
        return this.__asyncIterator__;
    },
    enumerable: false
});

Object.defineProperties(ExtendedAsyncGenerator, {
    current: {
        get() {
            const set = () => this.current = this.next().then(next);
            const next = value => set() && value;
            Object.defineProperty(this, 'current', { value: null, writable: true });
            return set();
        }
    }
});

function cachedNext(source) {
    let cached;
    const getNext = () => cached = source.next().then(link);
    const link = (value) => {
        !value.done && getNext();
        return value;
    };
    return {
        throw: source.throw,
        return: source.return,
        [Symbol.asyncIterator]: source[Symbol.asyncIterator],
        next: () => cached !== null && cached !== void 0 ? cached : getNext()
    };
}

function clone(source) {
    const cached = cachedNext(source[Symbol.asyncIterator]());
    let result;
    const done = new Promise((resolve, reject) => {
        result = {
            next: () => Promise.race([cached.next(), done]),
            return: () => (resolve(), DONE),
            throw: () => (reject(), DONE),
            [Symbol.asyncIterator]() { return this; }
        };
    });
    return result;
}

function from(source) {
    return Object.setPrototypeOf(clone(source), ExtendedAsyncGenerator.prototype);
}

async function* filter(source, test = Boolean, index = 0) {
    for await (const value of source)
        if (test(value, index++))
            yield value;
}
async function* filterValue(source, filterValue) {
    for await (const value of source)
        if (value == filterValue)
            yield value;
}

ExtendedAsyncGenerator.prototype.filter = function (test, index) {
    return from(typeof test == 'function' ? filter(this, test, index) : filterValue(this, test));
};

async function find(source, predicate, index = 0) {
    for await (const value of source)
        if (predicate(value, index++))
            return value;
    return new Promise(() => { });
}

ExtendedAsyncGenerator.prototype.find = function (predicate, index) {
    return find(this, predicate, index);
};

function first(source) {
    return source.next().then(({ value }) => value);
}

Object.defineProperties(ExtendedAsyncGenerator, {
    first: {
        get() {
            return first(this);
        }
    }
});

function isAsyncGenerator(v) {
    return v instanceof Object && Symbol.asyncIterator in v;
}

async function* flat(source) {
    for await (const value of source)
        if (isAsyncGenerator(value))
            yield* value;
        else
            yield value;
}

Object.defineProperties(ExtendedAsyncGenerator, {
    flat: {
        get() {
            return from(flat(this));
        }
    }
});

async function forEach(source, next, index = 0) {
    for await (const value of source)
        next(value, index++);
}

ExtendedAsyncGenerator.prototype.forEach = function (next, index) {
    forEach(this, next, index);
};

async function* map(source, next, index = 0) {
    for await (const value of source)
        yield next(value, index++);
}

function get(source, property, wrap = clone) {
    return wrap(map(source, data => data[property]));
}

ExtendedAsyncGenerator.prototype.get = function (key) {
    return get(this, key, from);
};

async function log(source, ...args) {
    let index = 0;
    for await (const value of source)
        console.log(++index + 'ยบ', ...args, value);
}

ExtendedAsyncGenerator.prototype.log = function (...args) {
    log(this, ...args);
};

ExtendedAsyncGenerator.prototype.map = function (next, index) {
    return from(map(this, next, index));
};

function start(source, value) {
    const generator = clone(source);
    const next = generator.next;
    generator.next = function () {
        this.next = next;
        return Promise.resolve({ value, done: false });
    };
    return generator;
}

ExtendedAsyncGenerator.prototype.start = function (value) {
    return from(start(this, value));
};

function call(source, method, wrap = clone, ...args) {
    return wrap(map(source, data => data[method](...args)));
}

ExtendedAsyncGenerator.prototype.call = function (key, ...args) {
    return call(this, key, from, ...args);
};

const FINISHED = {
    next: () => new Promise(() => { }),
    return: () => DONE,
    throw: () => DONE,
    [Symbol.asyncIterator]() { return this; }
};
async function* trigger(source, build) {
    let target = FINISHED;
    const empty = () => [];
    while (source !== FINISHED || target !== FINISHED) {
        yield* await Promise.race([
            source.next().then(({ value, done }) => done ? empty(source = FINISHED) : empty(target.return(), target = build(value))),
            target.next().then(({ value, done }) => done ? empty(target = FINISHED) : [value])
        ]);
    }
}

ExtendedAsyncGenerator.prototype.trigger = function (factory) {
    return from(trigger(this, factory));
};

async function* reduce(source, callbackfn, index = 0) {
    let previous = (await source.next()).value;
    for await (const value of source)
        yield previous = callbackfn(previous, value, index++);
}

ExtendedAsyncGenerator.prototype.reduce = function (next, index) {
    return from(reduce(this, next, index));
};

class AsyncGeneratorEmitter extends ExtendedAsyncGenerator {
    constructor() {
        super();
        this.emitterPromise = new Promise(resolve => this.resolve = resolve);
        const AsyncGeneratorEmitter = function (...args) { AsyncGeneratorEmitter.emit(...args); };
        return Object.setPrototypeOf(AsyncGeneratorEmitter, this);
    }
    async *[Symbol.asyncIterator]() {
        while (true)
            yield await this.emitterPromise.then(() => {
                this.emitterPromise = new Promise(resolve => this.resolve = resolve);
                return this.value;
            });
    }
    emit(value) {
        this.resolve(this.value = value);
    }
}

class EventGenerator extends AsyncGeneratorEmitter {
    constructor(element, type, options = {}) {
        super();
        this.element = element;
        this.type = type;
        this.options = options;
        this.handler = (event) => {
            this.options.preventDefault && event.preventDefault();
            this.options.stopPropagation && event.stopPropagation();
            if (!this.options.matches || event.target instanceof Element && event.target.matches(this.options.matches))
                super.emit(event instanceof CustomEvent ? event.detail : event);
        };
        element.addEventListener(type, this.handler);
    }
    matches(query) {
        this.options.matches = query;
        return this;
    }
    preventDefault(prevent = true) {
        this.options.preventDefault = prevent;
        return this;
    }
    stopPropagation(stop = true) {
        this.options.stopPropagation = stop;
        return this;
    }
    get target() {
        return this.map(event => event.target);
    }
    get detail() {
        return this.map(event => event['detail']);
    }
    get skidata() {
        return this.target.filter(element => element instanceof Node).map(element => element.skidata).get;
    }
    emit(detail) {
        this.element.dispatchEvent(new CustomEvent(this.type, { detail, bubbles: true }));
    }
    // decorator(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor {
    //   return null;
    // }
    remove() {
        this.element.removeEventListener(this.type, this.handler);
    }
}
const events$ = Symbol('events');
function events(context) {
    return context[events$] || (context[events$] = new Proxy(context, {
        has: (_, property) => typeof property == 'string',
        get(target, property) {
            if (property != property.toString().toLowerCase())
                console.warn(`Consider using only lowercase letters for event ${property.toString()} name`);
            if (property in this)
                return this[property];
            if (typeof property == 'string') {
                return this[property] = new EventGenerator(target, property);
            }
        }
    }));
}
Object.defineProperty(Node.prototype, 'events', {
    get() {
        return events(this);
    }
});
Object.defineProperty(Node.prototype, 'preventDefault', {
    set(eventList) {
        eventList.split(/\s+/).forEach(event => this.events[event].preventDefault());
    },
    get() {
        return new Proxy(this.events, {
            set(t, p, v) {
                t[p].preventDefault(v || (v === undefined));
                return true;
            }
        });
    }
});
window.events = events(window);

var Rule;
(function (Rule) {
    Rule[Rule["EQUALS"] = 0] = "EQUALS";
    Rule[Rule["PREFIX"] = 1] = "PREFIX";
    Rule[Rule["SUFFIX"] = 2] = "SUFFIX";
    Rule[Rule["SEPARATOR"] = 3] = "SEPARATOR";
    Rule[Rule["CONTAINS"] = 4] = "CONTAINS";
    Rule[Rule["SURROUNDING"] = 5] = "SURROUNDING";
})(Rule || (Rule = {}));
const ruleTest = {
    [Rule.EQUALS]: (str, type) => `${type} = "${str}"`,
    [Rule.PREFIX]: (str, type) => `starts-with(${type},"${str}")`,
    [Rule.SUFFIX]: (str, type) => `substring(${type},string-length(${type}) - ${str.length - 1}) = '${str}'`,
    [Rule.SEPARATOR]: (str, type) => `contains(${type}, '${str}')`,
    [Rule.CONTAINS]: (str, type) => `contains(${type}, '${str}')`,
    [Rule.SURROUNDING]: (str, type) => ruleTest[Rule.PREFIX](str, type) + ' and ' + ruleTest[Rule.SUFFIX](str, type)
};
const regexp = {
    [Rule.EQUALS]: (str) => new RegExp('(?=^' + escapeRegExp(str) + '$)'),
    [Rule.PREFIX]: (str) => new RegExp('^' + escapeRegExp(str)),
    [Rule.SUFFIX]: (str) => new RegExp(escapeRegExp(str) + '$'),
    [Rule.SEPARATOR]: (str) => new RegExp(`(?=.+${escapeRegExp(str)}.+)`),
    [Rule.CONTAINS]: (str) => new RegExp(`(?=.*${escapeRegExp(str)}.*)`),
    [Rule.SURROUNDING]: (str) => new RegExp(`(?=^${escapeRegExp(str)}.+${escapeRegExp(str)}$)`),
};
const escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
const xpathTest = (name, rule, type) => ruleTest[rule](name, type);
const xpathAttr = (name, rule) => `.//@*[${xpathTest(name, rule, 'name()')}]`;
const xpathContent = (name, rule) => `.//text()[${xpathTest(name, rule, 'normalize-space(.)')}]`;
const matcher = (name, rule) => regexp[rule](name);

class SkiNodeObserver {
    constructor(root) {
        this.root = root;
        // TODO: reuse MutationObserver since several are created for the same root ?
        this.mutationObserver = new MutationObserver(mutationsList => mutationsList.forEach(record => this.onChange(record)));
    }
    init() {
        let nodeClass = this.constructor;
        this.mutationObserver.observe(this.root, {
            attributeFilter: this.attributeFilter,
            attributeOldValue: nodeClass.attributeOldValue,
            attributes: nodeClass.attributes,
            characterData: nodeClass.characterData,
            characterDataOldValue: nodeClass.characterDataOldValue,
            childList: nodeClass.childList,
            subtree: nodeClass.subtree
        });
        this.updateTree(this.root);
        return this;
    }
    onChange(record) {
        var _a, _b;
        (_a = record.addedNodes) === null || _a === void 0 ? void 0 : _a.forEach(this.updateTree, this);
        (_b = record.removedNodes) === null || _b === void 0 ? void 0 : _b.forEach(this.detachTree, this);
    }
    disconnect() {
        this.mutationObserver.disconnect();
        this.detachTree(this.root);
    }
}

class SkiAttributeObserver extends SkiNodeObserver {
    constructor(root, name, rule) {
        super(root);
        this.evaluationSnapshot = true;
        this.camelCase = (name) => name.replace(/-([a-z])/g, g => g[1].toUpperCase());
        let attributeExpression = xpathAttr(name, rule);
        this.matches = matcher(name, rule);
        this.xPathExpression = document.createExpression(attributeExpression, null);
    }
    get evaluationType() {
        return this.evaluationSnapshot ? XPathResult.ORDERED_NODE_SNAPSHOT_TYPE : XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
    }
    attrName(name) {
        return name.replace(this.matches, '');
    }
    *findNodes(node) {
        if (node instanceof DocumentFragment)
            return node.childNodes.forEach(this.findNodes, this);
        let attributes = this.xPathExpression.evaluate(node, this.evaluationType);
        if (this.evaluationSnapshot)
            for (let i = 0, attr; attr = attributes.snapshotItem(i); i++)
                yield attr;
        else
            for (let attr; attr = attributes.iterateNext();)
                yield attr;
    }
    updateTree(node) {
        for (let attr of this.findNodes(node))
            this.update(attr, this.attrName(attr.name));
    }
    detachTree(node) {
        for (let attr of this.findNodes(node))
            this.update(attr, this.attrName(attr.name));
    }
    onChange(record) {
        var _a, _b;
        (_a = record.addedNodes) === null || _a === void 0 ? void 0 : _a.forEach(this.updateTree, this);
        (_b = record.removedNodes) === null || _b === void 0 ? void 0 : _b.forEach(this.detachTree, this);
        record.attributeName &&
            this.matches.test(record.attributeName) &&
            record.target instanceof Element &&
            this.update(record.target.attributes[record.attributeName], this.attrName(record.attributeName));
    }
}
SkiAttributeObserver.attributes = true;
SkiAttributeObserver.childList = true;
SkiAttributeObserver.subtree = true;

class Dependency {
}
class SkiDependencyEval {
    constructor(expression, context, scope) {
        this.expression = expression;
        this.context = context;
        this.scope = scope;
        this.original = new Map();
        this.valueMap = new Map();
        try {
            this.function = new Function('__arg0__', `with (__arg0__) return (${this.expression || undefined})`);
        }
        catch (e) {
            throw Error(`Creating function() {\n\t${expression})\n}\n${e}`);
        }
    }
    async *run() {
        do {
            this.original.clear();
            this.valueMap.clear();
            try {
                let result = this.function.call(this.context, new Proxy(this.scope, this));
                isAsyncGenerator(result) ?
                    yield* this.original.get(result) || result :
                    yield this.original.get(result) || result;
            }
            catch (e) {
                if (!(e instanceof Dependency))
                    throw Error(`Evaluating expression (${this.expression})\n${e}`);
            }
            await this.deps();
        } while (this.generators().length > 0);
        this.original.clear();
        this.valueMap.clear();
    }
    deps() {
        return Promise.race(this.generators().map(gen => SkiDependencyEval.generatorPromises.get(gen)));
    }
    generators() {
        return Array.from(this.valueMap.keys())
            .filter(data => isAsyncGenerator(data) && SkiDependencyEval.generatorPromises.has(data));
    }
    get dependencies() {
        return Array.from(this.valueMap.values());
    }
    get entries() {
        return new Map([...this.valueMap.entries()].map(([key, value]) => [value, key]));
    }
    proxy(data) {
        let result = new Proxy(data, this);
        this.original.set(result, data);
        return result;
    }
    register(target, property, value) {
        let chain = this.valueMap.get(target);
        this.valueMap.set(value, chain ? `${chain}.${property}` : property);
    }
    get(target, property, _receiver) {
        if (property === Symbol.unscopables)
            return target[property];
        if (!(property in target))
            throw ReferenceError(`${String(property)} is not defined in: ${target}`);
        let value = isAsyncGenerator(target) ?
            this.map(target, property) :
            target[property];
        this.register(target, String(property), value);
        if (isAsyncGenerator(value))
            value = this.generatorValue(value);
        return typeof value === 'object' ? this.proxy(value) : value;
    }
    map(generator, property) {
        const uniqueName = '__' + String(property) + '__';
        return generator[uniqueName] || (generator[uniqueName] = map(generator, v => v[property]));
    }
    generatorValue(generator) {
        if (SkiDependencyEval.generatorValues.has(generator))
            return SkiDependencyEval.generatorValues.get(generator);
        else {
            this.watchStream(generator);
            throw new Dependency();
        }
    }
    async watchStream(generator) {
        const name = this.valueMap.get(generator);
        let stream = generator[Symbol.asyncIterator]();
        if (!SkiDependencyEval.generatorPromises.has(generator)) {
            try {
                do {
                    let next = stream.next();
                    SkiDependencyEval.generatorPromises.set(generator, next);
                    var data = await next;
                    !data.done && SkiDependencyEval.generatorValues.set(generator, data.value);
                } while (!data.done);
            }
            finally {
                SkiDependencyEval.generatorPromises.delete(generator);
            }
        }
    }
}
SkiDependencyEval.generatorValues = new Map();
SkiDependencyEval.generatorPromises = new Map();

class SkiAttributeEvaluation extends SkiAttributeObserver {
    update(attr, target) {
        if (!attr.processed) {
            let element = attr.ownerElement;
            Object.assign(attr.skidata, this.prepare(element, attr));
            this.evaluate(element, attr, target, attr.value);
            attr.processed = true;
        }
    }
    detach(attr) {
        attr.skidata.result.return();
    }
    async evaluate(element, attr, propertyChain, expression) {
        const result = new SkiDependencyEval(expression, element, attr.skidata).run();
        attr.skidata.result = result;
        for await (let data of result)
            this.apply(element, propertyChain, data, attr);
    }
    attrSkiData(element, name) {
        return element.attributes[name].skidata;
    }
    prepare(_element, _attr) {
        return {};
    }
}

class SkiAssociation extends SkiAttributeEvaluation {
    constructor(root, name = ':', rule = Rule.SUFFIX) {
        super(root, name, rule);
    }
    apply(element, target, data) {
        let chain = target.split('.').map(this.camelCase);
        let property = chain.pop();
        chain.reduce((data, name) => data[name], element)[property] = data;
    }
}
for (let unit of ['em', 'ex', 'px', 'cm', 'mm', 'in', 'pt', 'pc', 'ch', 'rem', 'vh', 'vw', 'vmin', 'vmax'])
    Object.defineProperty(Number.prototype, unit, { get() { return this + unit; } });
Object.defineProperty(Number.prototype, 'percent', { get() { return this + '%'; } });

/**
 * Toggle element classes defined as attribute with live updates
 * @param attr An attribute with name starting with . (dot)
 * The attribute name can be chained like .name1.name2.name3
 *
 * @explample condictional element class
 * ```html
 * <span .name1.name2="expressionA" .name3="expressionB">text</span>
 * ```
 * will be transformed into:
 * ```html
 * <span class="name1 name2">text</span>
 * ```
 * if expressionA evaluates to `true` and expressionB evaluates to `false`
 *
 * if expression is missing, the condiction is considered to be truty and the class is added to the element class list
 * @explample conditionless element class
 * ```html
 * <span .name1 .name2>text</span>
 * ```
 * will be transformed into:
 * ```html
 * <span class="name1 name2">text</span>
 * ```
 */
class SkiClass extends SkiAttributeEvaluation {
    constructor(root, name = '.', rule = Rule.PREFIX) {
        super(root, name, rule);
    }
    apply(element, target, enable) {
        let classes = target.split('.');
        for (let name of classes)
            this.toggleClass(element, name, enable);
    }
    toggleClass(element, name, enable) {
        element.classList.toggle(name, enable || enable === undefined);
    }
}
SkiClass.evaluationSnapshot = false;

class SkiTagObsever extends SkiNodeObserver {
    constructor(root, name) {
        super(root);
        this.name = name;
    }
    updateTree(node) {
        'querySelectorAll' in node && node.querySelectorAll(this.name).forEach(this.update, this);
    }
    detachTree(node) {
        'querySelectorAll' in node && node.querySelectorAll(this.name).forEach(this.detach, this);
    }
}
SkiTagObsever.childList = true;
SkiTagObsever.subtree = true;

const val = Symbol('val');
class SkiVal extends SkiTagObsever {
    constructor(root, name = 'val') {
        super(root, name);
    }
    async update(element) {
        let text = document.createTextNode('');
        element.replaceWith(text);
        let result = new SkiDependencyEval(element.textContent, text, text.skidata).run();
        text[val] = result;
        for await (let value of result)
            text.textContent = value;
    }
    detachTree(node) {
        let textNodes = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, {
            acceptNode: (node) => val in node ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
        }, false);
        for (let textNode; textNode = textNodes.nextNode();)
            this.detach(textNode);
    }
    detach(text) {
        text[val].return();
    }
}

class SkiPropertyObserver extends SkiAttributeEvaluation {
    constructor(root, attr) {
        super(root, attr, Rule.EQUALS);
        this.attr = attr;
        this.attributeFilter = [this.attr];
        this.defineProperty();
    }
    apply(element, attr, value) {
        this.set(element, value, element.attributes[attr].skidata);
    }
    // protected onChange(record: MutationRecord) {
    //   record.target instanceof Element &&
    //     record.attributeName! in record.target.attributes &&
    //       !attr.processed && 
    //         this.update(record.target.attributes[record.attributeName!], record.attributeName!);
    // }
    setAttribute(element, value) {
        const isPrimitive = value => value !== Object(value);
        if (value === undefined || value === null || !isPrimitive(value))
            element.removeAttribute(value);
        else if (value.toString() != element.getAttribute(this.attr))
            element.setAttribute(this.attr, value); // this will trigger onChange again
    }
    defineProperty() {
        const set = this.set.bind(this);
        const attr = this.attr;
        attr in Element.prototype ||
            Object.defineProperty(Element.prototype, this.attr, {
                set(value) {
                    set(this, value, this.attributes[attr].skidata);
                },
                enumerable: false,
                configurable: false
            });
    }
}
SkiPropertyObserver.subtree = true;
SkiPropertyObserver.attributes = true;
SkiPropertyObserver.childList = false;

class SkiCondiction extends SkiPropertyObserver {
    constructor(root, attr, fallback) {
        super(root, attr);
        this.fallback = fallback;
    }
    prepare(element) {
        var _a;
        const tag = element.tagName.toLowerCase();
        const elseElement = this.fallback && ((_a = element.nextElementSibling) === null || _a === void 0 ? void 0 : _a.matches(`[${this.fallback}]`)) && element.nextElementSibling;
        return {
            placeholder: elseElement || document.createComment(`<${tag}>hidden</${tag}>`)
        };
    }
    set(element, value, { placeholder }) {
        if (this.checkCondiction(value, element))
            placeholder.parentNode && placeholder.replaceWith(element);
        else
            element.parentNode && element.replaceWith(placeholder);
    }
}

class SkiIf extends SkiCondiction {
    constructor(root, attr = 'if', fallback = 'else') {
        super(root, attr, fallback);
    }
    checkCondiction(value) {
        return value;
    }
}

class SkiLet extends SkiAttributeObserver {
    constructor(root, data, name = 'let-', rule = Rule.PREFIX) {
        super(root, name, rule);
        data && Object.assign(root.skidata, data);
    }
    update(attr, target) {
        if (!attr.processed) {
            let element = attr.ownerElement;
            const result = new SkiDependencyEval(attr.value, element, element.skidata).run();
            this.apply(element, target, result);
            attr.processed = true;
        }
    }
    detach() {
    }
    apply(element, name, value) {
        element.skidata[this.camelCase(name)] = value;
    }
}

class SkiUnless extends SkiCondiction {
    constructor(root, attr = 'unless', fallback = 'else') {
        super(root, attr, fallback);
    }
    checkCondiction(value) {
        return value === undefined ? false : !value;
    }
}

class SkiRepeat extends SkiPropertyObserver {
    constructor(root, name = 'for', attr = 'of') {
        super(root, attr);
        this.name = name;
    }
    prepare(element) {
        let template = document.createDocumentFragment();
        template.append(...element.childNodes);
        return { template, children: new WeakMap() };
    }
    set(element, value, content) {
        let name = element.getAttribute(this.name);
        element.innerHTML = '';
        element.append(...value.map((item, index) => {
            let node = this.getNode(content, item);
            node.childNodes.forEach(node => Object.assign(node.skidata, name ? { [name]: item, index } : item));
            return node;
        }));
        delete element.skidata.index;
    }
    getNode(content, item) {
        let node = typeof item == 'object' && content.children.get(item);
        if (!node) {
            node = content.template.cloneNode(true);
            typeof item == 'object' && content.children.set(item, node);
        }
        return node;
    }
}

class SkiSwitch extends SkiPropertyObserver {
    constructor(root, attr = 'switch', condiction = 'case', fallback = 'default') {
        super(root, attr);
        this.condiction = condiction;
        this.fallback = fallback;
    }
    prepare(element) {
        return {
            contents: Array.from(element.children).map(child => element.removeChild(child))
        };
    }
    match(value, contents) {
        return contents.find(element => element.getAttribute(this.condiction) == value) ||
            contents.find(element => element.hasAttribute(this.fallback)) ||
            document.createComment("unmatched condiction");
    }
    set(element, value, { contents }) {
        var _a, _b;
        let match = this.match(value, contents);
        (_b = (_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.replaceWith(match)) !== null && _b !== void 0 ? _b : element.appendChild(match);
    }
}

class SkiEventTrigger extends SkiAttributeObserver {
    constructor(root, separator = '|') {
        super(root, separator, Rule.SEPARATOR);
        this.separator = separator;
    }
    update(attr, target) {
        if (!attr.processed) {
            let element = attr.ownerElement;
            let [listen, emit] = this.camelCase(target).split(this.separator);
            let evaluator = new SkiDependencyEval(attr.value, element, attr.skidata);
            const emitter = element.events[emit];
            element.events[listen].forEach((event) => {
                let copy = {};
                // for (const name in event) copy[name] = event[name];
                Object.assign(attr.skidata, { event }, copy);
                evaluator.run().next().then(({ value }) => emitter(value));
            });
            attr.processed = true;
        }
    }
    async update_(attr, target) {
        if (!attr.processed) {
            const [listen, emit] = this.camelCase(target).split(this.separator);
            const element = attr.ownerElement;
            const listener = element.events[listen];
            const emitter = element.events[emit];
            attr.skidata.event = listener;
            const evaluator = new SkiDependencyEval(attr.value, element, attr.skidata);
            listener.trigger(() => evaluator.run()).forEach(emitter);
            attr.processed = true;
        }
    }
    detach(attr, target) {
        let [listen] = this.camelCase(target).split(this.separator);
        let element = attr.ownerElement;
        element.events[listen].return();
    }
}
SkiEventTrigger.evaluationSnapshot = false;

class SkiName extends SkiAttributeObserver {
    constructor(root, name = '#', rule = Rule.PREFIX) {
        super(root, name, rule);
    }
    update(attr, target) {
        // TODO: find a better way of handling "attr.processed"
        if (!attr.processed) {
            this.root.skidata[target] = attr.ownerElement; //.events;
            attr.processed = true;
        }
    }
    detach(_attr, target) {
        this.root.skidata[target].return();
    }
}

class SkiAll {
    constructor(root, data = {}) {
        this.all = [
            new SkiName(root, '#', Rule.PREFIX),
            new SkiLet(root, data, 'let-', Rule.PREFIX),
            new SkiRepeat(root, 'for', 'of'),
            new SkiAssociation(root, ':', Rule.SUFFIX),
            new SkiClass(root, '.', Rule.PREFIX),
            new SkiIf(root, 'if', 'else'),
            new SkiUnless(root, 'unless', 'else'),
            new SkiSwitch(root, 'switch', 'case', 'default'),
            new SkiVal(root, 'val'),
            // new SkiTemplateString(root, '`', Rule.SURROUNDING),
            // new SkiInlineExpression(root, '{{', '}}'),
            new SkiEventTrigger(root, '|')
        ];
    }
    init() {
        this.all.forEach(e => e.init());
    }
    disconnect() {
        this.all.forEach(e => e.disconnect());
    }
}

const IMPORT_REGEXP = /import\s+?(?:(?:(?:[\w*\s{},]*)\s+from\s+?)|)(?:(?:"(?:.*?)")|(?:'(?:.*?)'))[\s]*?(?:;|$|)/g;
const addOriginToImports = (content, basepath) => content.replace(IMPORT_REGEXP, substring => {
    let [_import, _from, _end] = substring.split(/'|"/);
    let origin_from = new URL(_from, basepath);
    return `${_import}'${origin_from}'${_end}`;
});
async function importModuleContent(content, basepath) {
    content = addOriginToImports(content, basepath);
    let blob = new Blob([content], { type: 'text/javascript' });
    let dynamic_url = URL.createObjectURL(blob) + '#';
    try {
        return await import(dynamic_url);
    }
    finally {
        URL.revokeObjectURL(dynamic_url);
    }
}

const uninitialized = Symbol();
/**
 *  @example
 *  let prop = new SkiProperty<number>();
 *  >> for await (let value of prop) console.log('changed', value);
 *  prop.set(20);
 *  prop.set(50);
 *  >> log: changed 50
 *
 */
class SkiProperty {
    constructor(currentValue = uninitialized) {
        this.currentValue = currentValue;
        this.promise = this.newPromise();
        this.get = () => this.currentValue != uninitialized ? this.currentValue : undefined;
        this.set = (value) => {
            if (value !== this.currentValue) {
                this.resolveNext(this.currentValue = value);
                this.promise = this.newPromise();
            }
            return this;
        };
        this.enumerable = true;
        this.configurable = true;
    }
    newPromise() {
        return new Promise(resolve => this.resolveNext = resolve);
    }
    async *[Symbol.asyncIterator]() {
        if (this.currentValue !== uninitialized)
            yield this.currentValue;
        while (true)
            yield await this.next();
    }
    async next() {
        await this.promise;
        return this.currentValue;
    }
    static wrap(object, name) {
        let descriptor = Object.getOwnPropertyDescriptor(object, name);
        let property = descriptor && SkiProperty.map.get(descriptor);
        if (!property) {
            property = new SkiProperty(object[name]);
            Object.defineProperty(object, name, property);
            descriptor = Object.getOwnPropertyDescriptor(object, name);
            SkiProperty.map.set(descriptor, property);
        }
        return property;
    }
}
SkiProperty.map = new WeakMap();

class SkiComponent extends HTMLElement {
    constructor() {
        super();
        this.basepath = new URL(location.origin);
        this.content = document.createDocumentFragment();
        this.content.append(...this.childNodes);
        const name = this.getAttribute('name');
        const extendsComponent = this.getAttribute('extends');
        this.createComponent(name, extendsComponent);
    }
    async createComponent(name, extendsComponent) {
        const baseComponent = extendsComponent ? (await customElements.whenDefined(extendsComponent),
            await customElements.get(extendsComponent)) :
            HTMLElement;
        const modules = await Array.from(this.content.querySelectorAll('script[type=module]'))
            .map(module => module.src ?
            import(new URL(module.src, this.basepath).href) :
            importModuleContent(module.innerHTML, this.basepath))
            .reduce(async (modules, module) => Object.assign(await modules, await module), Promise.resolve({}));
        createComponent(name, this.content, baseComponent, modules.default);
    }
}
function initSkiComponent(name = 'ski-component') {
    window.customElements.get(name) || customElements.define(name, SkiComponent);
}
function createComponent(name, content, baseComponent, objectClass) {
    var _a;
    var _b;
    const attributes = Object.keys((_a = objectClass === null || objectClass === void 0 ? void 0 : objectClass.properties) !== null && _a !== void 0 ? _a : {});
    const component = (_b = class extends baseComponent {
            constructor() {
                super();
                const shadowRoot = this.attachShadow({ mode: 'open' });
                shadowRoot.append(content.cloneNode(true));
                Object.assign(shadowRoot.skidata, this.properties = this.buildProperties());
            }
            buildProperties() {
                let object = objectClass ? new objectClass(this) : {};
                let properties = Object.fromEntries(attributes.map(name => [name, SkiProperty.wrap(this, name)]));
                Object.defineProperties(object, properties);
                return properties;
            }
            connectedCallback() {
                this.ski = new SkiAll(this.shadowRoot, this.skidata);
            }
            disconnectedCallback() {
                var _a;
                (_a = this.ski) === null || _a === void 0 ? void 0 : _a.disconnect();
            }
            attributeChangedCallback(name, _oldValue, newValue) {
                this.properties[name].set(newValue);
            }
        },
        _b.observedAttributes = attributes,
        _b);
    customElements.define(name, component);
}

const templateEval = Symbol('templateEval');
class SkiTemplateString extends SkiNodeObserver {
    constructor(root, char = '`', rule = Rule.SURROUNDING) {
        super(root);
        let contentExpression = xpathContent(char, rule);
        this.xPathExpression = document.createExpression(contentExpression, null);
    }
    updateTree(node) {
        let nodes = this.xPathExpression.evaluate(node, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE);
        for (let i = 0, node; node = nodes.snapshotItem(i); i++)
            this.update(node, node.textContent);
    }
    detachTree(node) {
        this.detach(node);
        let textNodes = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, {
            acceptNode: (node) => templateEval in node ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
        }, false);
        for (let textNode; textNode = textNodes.nextNode();)
            this.detach(textNode);
    }
    async update(node, content) {
        let result = new SkiDependencyEval(content, node, node.skidata).run();
        node[templateEval] = result;
        node.textContent = '';
        for await (let value of result)
            node.textContent = value;
    }
    detach(node) {
        var _a;
        (_a = node[templateEval]) === null || _a === void 0 ? void 0 : _a.return();
    }
}
SkiTemplateString.childList = true;
SkiTemplateString.subtree = true;

const expression = Symbol('expression');
class SkiInlineExpression extends SkiNodeObserver {
    constructor(root, prefix = '{{', suffix = '}}') {
        super(root);
        this.prefix = prefix;
        this.suffix = suffix;
        let contentExpression = xpathContent(prefix, Rule.CONTAINS);
        this.xPathExpression = document.createExpression(contentExpression, null);
    }
    updateTree(node) {
        let nodes = this.xPathExpression.evaluate(node, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE);
        for (let i = 0, node; node = nodes.snapshotItem(i); i++)
            this.splitText(node);
    }
    detachTree(node) {
        let textNodes = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, {
            acceptNode: (node) => expression in node ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
        }, false);
        for (let textNode; textNode = textNodes.nextNode();)
            this.detach(textNode);
    }
    async splitText(text) {
        let index = text.textContent.indexOf(this.prefix);
        while (~index) {
            let expression = text.splitText(index);
            index = expression.textContent.indexOf(this.suffix);
            text = ~index ? expression.splitText(index + this.suffix.length) : expression;
            ~index && this.updateText(expression);
            index = text.textContent.indexOf(this.prefix);
        }
    }
    async updateText(text) {
        const content = text.textContent.substring(this.prefix.length, text.textContent.length - this.suffix.length);
        let result = new SkiDependencyEval(content, text, text.skidata).run();
        text[expression] = result;
        text.textContent = '';
        for await (let value of result)
            text.textContent = value;
    }
    detach(text) {
        var _a;
        (_a = text[expression]) === null || _a === void 0 ? void 0 : _a.return();
    }
}
SkiInlineExpression.childList = true;
SkiInlineExpression.subtree = true;

function skiInit(root, data = {}) {
    initSkiComponent('ski-component');
    return new SkiAll(root, data).init();
}

export { ExtendedAsyncGenerator, Rule, SkiAssociation, SkiClass, SkiEventTrigger, SkiIf, SkiInlineExpression, SkiLet, SkiName, SkiRepeat, SkiSwitch, SkiTemplateString, SkiUnless, SkiVal, initSkiComponent, skiInit };
